{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ILEE_CSK The eukaryotic cytoskeleton plays essential roles in cell signaling, trafficking, and motion. We aim to provide the best cytoskeleton segmentation-analysis algorithm and platform. ILEE_CSK is a Python library that provides a platform for unguided and automated quantitative analysis of cytoskeletal images at high accuracy, which support both 2D and native 3D data structure. ILEE means Implicit Laplacian of Enhanced Edge, which is a local thresholding algorithm that detects and uses the edge of cytoskeleton filaments as the local baseline for fine thresholding. Our robust algorithm captures and computes native pixel/voxel value, first-order derivative (gradient), and second-order derivative (Laplacian) of the image to automatedly generate a threshold image for cytoskeleton segmentation. The binary image of cytoskeleton fraction, together with the raw image is processed to compute more than 10 cytoskeleton indices, which are the matrices that measure the cytoskeletal features, of 5 classes: density, bundling, severing, branching, and directionality. The generated data can be used to determine and discover critical cytoskeletal feature of your own biological samples. In general, ILEE_CSK provides following state-of-art features to make outstanding performance: Support of native 3D mode, avoiding image projection that losses a considerable amount of information perpendicular to z-axis. Unguided algorithm, avoiding human-bias related to subjective judgment in manual global thresholding, the currently most popular approach. High accuracy, the top among the kind. Please read our paper. Most complete cytoskeleton index list, with many novel indices developed by ourselves. Demo of performance Below is a demo of the visualized data of selected cytoskeleton indices produced by ILEE. The Demo image is a live sample of Arabidopsis leaf actin, with GFP-fABD2 marker: Below is a comparison of ILEE and other classic image segmentation approaches, by pixel-wise accuracy (top) and indice accuracy (bottom): Below is a demo of ILEE performance on other types of eukaryotic cytoskeleton samples. The top is Arabidopsis leaf microtubule; the bottom is human cancer cell actin:","title":"Home"},{"location":"#ilee_csk","text":"The eukaryotic cytoskeleton plays essential roles in cell signaling, trafficking, and motion. We aim to provide the best cytoskeleton segmentation-analysis algorithm and platform. ILEE_CSK is a Python library that provides a platform for unguided and automated quantitative analysis of cytoskeletal images at high accuracy, which support both 2D and native 3D data structure. ILEE means Implicit Laplacian of Enhanced Edge, which is a local thresholding algorithm that detects and uses the edge of cytoskeleton filaments as the local baseline for fine thresholding. Our robust algorithm captures and computes native pixel/voxel value, first-order derivative (gradient), and second-order derivative (Laplacian) of the image to automatedly generate a threshold image for cytoskeleton segmentation. The binary image of cytoskeleton fraction, together with the raw image is processed to compute more than 10 cytoskeleton indices, which are the matrices that measure the cytoskeletal features, of 5 classes: density, bundling, severing, branching, and directionality. The generated data can be used to determine and discover critical cytoskeletal feature of your own biological samples. In general, ILEE_CSK provides following state-of-art features to make outstanding performance: Support of native 3D mode, avoiding image projection that losses a considerable amount of information perpendicular to z-axis. Unguided algorithm, avoiding human-bias related to subjective judgment in manual global thresholding, the currently most popular approach. High accuracy, the top among the kind. Please read our paper. Most complete cytoskeleton index list, with many novel indices developed by ourselves.","title":"ILEE_CSK"},{"location":"#demo-of-performance","text":"Below is a demo of the visualized data of selected cytoskeleton indices produced by ILEE. The Demo image is a live sample of Arabidopsis leaf actin, with GFP-fABD2 marker: Below is a comparison of ILEE and other classic image segmentation approaches, by pixel-wise accuracy (top) and indice accuracy (bottom): Below is a demo of ILEE performance on other types of eukaryotic cytoskeleton samples. The top is Arabidopsis leaf microtubule; the bottom is human cancer cell actin:","title":"Demo of performance"},{"location":"API/","text":"API General batch-processing pipeline opt_k2 (folder_path, target_channel = None): This functions calculates the optimal K2 for a batch of samples (raw TIFF files) to be analyzed. Please include all samples of different categorical groups to be compared into the same folder. Parameters: folder_path : string, a local path of your image samples. The final document name should contain an \"/\" in the end, for example, folder_path = 'D:/experiment/all my samples/' target_channel : int, optional. It should be an provided int for most of the situations. If your raw TIFF file does not have the channel dimension, please use default None. Returns: K2: float, the estimated optimal K2 for the total batch of sample for comparison analyze_document_2D (folder_path, obj_channel, k2, pixel_size = 1): Process and analyze all the raw tiff samples in the folder by 2D mode and output the result as a table (Pandas DataFrame). All images are linearly transformed to 12-bit to be compatible. In 2D mode, K1 = 2.5. Parameters: folder_path : string, a local path of your image samples. The final document name should contain an \"/\" in the end, for example, folder_path = 'D:/experiment/all my samples/' obj_channel : int. The channel index of cytoskeleton fluoresence in the 4D array read from raw TIFF k2 : number. The universal K2. Recommend use the optimal K2 calculated by the function opt_k2 pixel_size : number, optional. The physical lenghth unit of your pixel, by micrometer (\u03bcm). The default is 1. If you set it into the real pixel size, the unit \"PU\" in the output table should be regarded as \u03bcm. Returns: Pandas DataFrame, all cytoskeleton indices. It can be processed inside python IDE or export it as excel file. analyze_document_3D (folder_path, obj_channel, k2, xy_unit, z_unit, pixel_size = 1, single_k = True, use_GPU = False): Process and analyze all the raw tiff samples in the folder by 3D mode and output the result as a table (dataframe). All images are automatically transformed to 12-bit to be compatible. Please note that it can be slow if the MATLAB-based GPU acceleration is not available. In 3D mode, K1 = 10^((log10(2.5)+log10(K2))/2). Parameters folder_path : string, a local path of your image samples. The final document name should contain an \"/\" in the end, for example, folder_path = 'D:/experiment/all my samples/' obj_channel : int, your channel index of cytoskeleton fluoresence in the 4D array read from raw TIFF. k2 : number, the universal K2. Recommend use the optimal K2 calculated by the function opt_k2. xy_unit : number, the unit size of x- and y-axis by \u03bcm. Please check using ImageJ. z_unit : number, the unit size of z-axis by \u03bcm, which is also the step size of stack imaging. Please check using ImageJ. pixel_size : number, optional. The physical lenghth unit (on x- and y-axis) of your voxel, by micrometer (\u03bcm). The default is 1. If you set it into the real pixel size, it should be equal to the parameter xy_unit, and the unit \"PU\" in your output table should be considered as \u03bcm. single_k : bool, optional. Whether to use single-K mode (use only K1, see above) to save time. The default is True. use_GPU : bool, optional. Whether to activate GPU acceleration. We highly recommend you turn it on if you have MATLAB and compatible GPU. The default is False. Returns Pandas DataFrame, all cytoskeleton indices. You can process it inside python IDE or export it as excel file. Processing individual sample rearrange_image_dimension (img, target_channel = None): Transform your image array of any dimension order (most likely x(height)-y(width)-z(stack)-channel or channel-x-y-z structure, depending on your confocal microscope) into z-x-y array of your object channel only. This function depends on sorting, so your channel number must be lower than your stack number, and your stack number (z-resolution) must be lower than your x and y resolution. Parameters img : 3D or 4D array, the image read from a tiff file by skimage.io target_channel : int, the cytoskeleton fluorescence channel index. If img is 3D array (only one channel, which is your cytoskeleton), target_channel must be None. Returns 3D array, the image of your object channel extracted from TIFF-generated 4D array, in z-x-y format . ILEE_2d (img, k2, k1 = 2.5, pL_type = 'pL_8', gauss_dif = True): Generate a difference image (raw_image - threshold_image) as ILEE output for downstream analysis or visualization, using 2D mode. Parameters img : float 2D array. An image of z-axis maximum projection of your target channel or the 2D \"raw\" image. Values should be transformed into float type with 0-4095 dynamic range. For example, if you have a 12 bit int-type image, as img input, then it should be used as img.astype('float'); if you have a 16 bit int-type image, then you should transform img into img = img.astype('float')/65535*4095. k2 : a number; should be the pre-determined optimal K2 for comparison purpose. k1 : The default is 2.5, which can identify one-pixel-size filament. pL_type : string, Laplacian matrix type. The default and recommended is 'pL_8'. An alternative is 'pL_4'. Please read our publication for further information. gauss_dif : Bool, default is True; whether the difference image is slightly gaussian-blurred for smoother render. Returns float 2D array, the rendered 2D difference image. analyze_actin_2d_standard (img, img_dif, pixel_size = 1): Compute all cytoskeleton indices using 2d raw and difference image as input. Parameters img : float 2D array. The input 2D image. img_dif : float 2D array. The difference image (raw_image - threshold_image) generated by ILEE_2d. pixel_size : number, optional. The physical lenghth unit of your pixel, by micrometer (\u03bcm). The default is 1. If it is set as the physical pixel size by \u03bcm, the unit \"PU\" in your output table should be regarded as \u03bcm as well. Returns pandas.DataFrame, all cytoskeleton indices of input sample: occupancy, linear_density, skewness, cv, Diameter_tdt, Diameter_sdt, sev_act, branching_act, anisotropy. ILEE_3d (img, xy_unit, z_unit, k1, k2, single_k1 = False, use_matlab = False, use_matlabGPU = False, gauss_dif = True): Generate a difference image (raw_image - threshold_image) as ILEE output for downstream analysis or visualization, using 3D mode. Parameters img : 3D array. The input 3D image. Values should be transformed into float type with 12-bit (0-4095) dynamic range. For example, if you have a 12 bit int-type image, as the img input, then it should be used as img.astype('float'); if you have a 16 bit int-type image, then you should transform img into img = img.astype('float')/65535*4095. xy_unit : number. The unit size of voxel on x- and y-axis by \u03bcm. Please check using ImageJ. z_unit : number. The unit size of voxel on z-axis by \u03bcm, which is also your step size of stack imaging. Please check using ImageJ. k1 : number. ILEE K1. for 3D mode we recommend K1 = 10^((log10(2.5)+log10(K2))/2). k2 : number. ILEE K2. single_k1 : bool, optional. Whether to use single-K mode (use only K1) to save time. The default is False. use_matlab : bool, optional. Whether to use MATLAB for ILEE. The default is False. use_matlabGPU : bool, optional. Whether to activate GPU_acceleration in MATLAB. The default is False. If use_matlab is False, this makes no difference. gauss_dif : Bool, optional. Whether the difference image is gaussian-blurred slightly for smoother render. Default is True. Returns float 3D array, the rendered 3D difference image, the same shape as input. analyze_actin_3d_standard (img, img_dif_ori, xy_unit, z_unit, oversampling_for_bundle = True, pixel_size = 1): Compute all cytoskeleton indices using 3d raw and difference image as input. Parameters img : 3D array. Input 3D image img_dif_ori : 3D array. The difference image to define the cytoskeleton components. xy_unit : number. The unit size of voxel on x- and y-axis by \u03bcm. Please check using ImageJ. z_unit : number. The unit size of voxel on z-axis by \u03bcm, which is also your step size of stack imaging. Please check using ImageJ. oversampling_for_bundle : bool, optional. Whether to use oversampled image to calculated diameter indices. Recommend to turn on for accuracy. The default is True. pixel_size : number, optional. The physical lenghth unit (on x- and y-axis) of your voxel, by micrometer (\u03bcm). The default is 1. If it is set as using physical length unit such as \u03bcm, it should be equal to the parameter xy_unit, and the unit \"PU\" in the output table should be considered as \u03bcm as well. Returns Pandas DataFrame, all cytoskeleton indices of input sample: occupancy, linear_density, skewness, cv, Diameter_tdt, Diameter_sdt, sev_act, branching_act, anisotropy.","title":"API"},{"location":"API/#api","text":"","title":"API"},{"location":"API/#general-batch-processing-pipeline","text":"opt_k2 (folder_path, target_channel = None): This functions calculates the optimal K2 for a batch of samples (raw TIFF files) to be analyzed. Please include all samples of different categorical groups to be compared into the same folder. Parameters: folder_path : string, a local path of your image samples. The final document name should contain an \"/\" in the end, for example, folder_path = 'D:/experiment/all my samples/' target_channel : int, optional. It should be an provided int for most of the situations. If your raw TIFF file does not have the channel dimension, please use default None. Returns: K2: float, the estimated optimal K2 for the total batch of sample for comparison analyze_document_2D (folder_path, obj_channel, k2, pixel_size = 1): Process and analyze all the raw tiff samples in the folder by 2D mode and output the result as a table (Pandas DataFrame). All images are linearly transformed to 12-bit to be compatible. In 2D mode, K1 = 2.5. Parameters: folder_path : string, a local path of your image samples. The final document name should contain an \"/\" in the end, for example, folder_path = 'D:/experiment/all my samples/' obj_channel : int. The channel index of cytoskeleton fluoresence in the 4D array read from raw TIFF k2 : number. The universal K2. Recommend use the optimal K2 calculated by the function opt_k2 pixel_size : number, optional. The physical lenghth unit of your pixel, by micrometer (\u03bcm). The default is 1. If you set it into the real pixel size, the unit \"PU\" in the output table should be regarded as \u03bcm. Returns: Pandas DataFrame, all cytoskeleton indices. It can be processed inside python IDE or export it as excel file. analyze_document_3D (folder_path, obj_channel, k2, xy_unit, z_unit, pixel_size = 1, single_k = True, use_GPU = False): Process and analyze all the raw tiff samples in the folder by 3D mode and output the result as a table (dataframe). All images are automatically transformed to 12-bit to be compatible. Please note that it can be slow if the MATLAB-based GPU acceleration is not available. In 3D mode, K1 = 10^((log10(2.5)+log10(K2))/2). Parameters folder_path : string, a local path of your image samples. The final document name should contain an \"/\" in the end, for example, folder_path = 'D:/experiment/all my samples/' obj_channel : int, your channel index of cytoskeleton fluoresence in the 4D array read from raw TIFF. k2 : number, the universal K2. Recommend use the optimal K2 calculated by the function opt_k2. xy_unit : number, the unit size of x- and y-axis by \u03bcm. Please check using ImageJ. z_unit : number, the unit size of z-axis by \u03bcm, which is also the step size of stack imaging. Please check using ImageJ. pixel_size : number, optional. The physical lenghth unit (on x- and y-axis) of your voxel, by micrometer (\u03bcm). The default is 1. If you set it into the real pixel size, it should be equal to the parameter xy_unit, and the unit \"PU\" in your output table should be considered as \u03bcm. single_k : bool, optional. Whether to use single-K mode (use only K1, see above) to save time. The default is True. use_GPU : bool, optional. Whether to activate GPU acceleration. We highly recommend you turn it on if you have MATLAB and compatible GPU. The default is False. Returns Pandas DataFrame, all cytoskeleton indices. You can process it inside python IDE or export it as excel file.","title":"General batch-processing pipeline"},{"location":"API/#processing-individual-sample","text":"rearrange_image_dimension (img, target_channel = None): Transform your image array of any dimension order (most likely x(height)-y(width)-z(stack)-channel or channel-x-y-z structure, depending on your confocal microscope) into z-x-y array of your object channel only. This function depends on sorting, so your channel number must be lower than your stack number, and your stack number (z-resolution) must be lower than your x and y resolution. Parameters img : 3D or 4D array, the image read from a tiff file by skimage.io target_channel : int, the cytoskeleton fluorescence channel index. If img is 3D array (only one channel, which is your cytoskeleton), target_channel must be None. Returns 3D array, the image of your object channel extracted from TIFF-generated 4D array, in z-x-y format . ILEE_2d (img, k2, k1 = 2.5, pL_type = 'pL_8', gauss_dif = True): Generate a difference image (raw_image - threshold_image) as ILEE output for downstream analysis or visualization, using 2D mode. Parameters img : float 2D array. An image of z-axis maximum projection of your target channel or the 2D \"raw\" image. Values should be transformed into float type with 0-4095 dynamic range. For example, if you have a 12 bit int-type image, as img input, then it should be used as img.astype('float'); if you have a 16 bit int-type image, then you should transform img into img = img.astype('float')/65535*4095. k2 : a number; should be the pre-determined optimal K2 for comparison purpose. k1 : The default is 2.5, which can identify one-pixel-size filament. pL_type : string, Laplacian matrix type. The default and recommended is 'pL_8'. An alternative is 'pL_4'. Please read our publication for further information. gauss_dif : Bool, default is True; whether the difference image is slightly gaussian-blurred for smoother render. Returns float 2D array, the rendered 2D difference image. analyze_actin_2d_standard (img, img_dif, pixel_size = 1): Compute all cytoskeleton indices using 2d raw and difference image as input. Parameters img : float 2D array. The input 2D image. img_dif : float 2D array. The difference image (raw_image - threshold_image) generated by ILEE_2d. pixel_size : number, optional. The physical lenghth unit of your pixel, by micrometer (\u03bcm). The default is 1. If it is set as the physical pixel size by \u03bcm, the unit \"PU\" in your output table should be regarded as \u03bcm as well. Returns pandas.DataFrame, all cytoskeleton indices of input sample: occupancy, linear_density, skewness, cv, Diameter_tdt, Diameter_sdt, sev_act, branching_act, anisotropy. ILEE_3d (img, xy_unit, z_unit, k1, k2, single_k1 = False, use_matlab = False, use_matlabGPU = False, gauss_dif = True): Generate a difference image (raw_image - threshold_image) as ILEE output for downstream analysis or visualization, using 3D mode. Parameters img : 3D array. The input 3D image. Values should be transformed into float type with 12-bit (0-4095) dynamic range. For example, if you have a 12 bit int-type image, as the img input, then it should be used as img.astype('float'); if you have a 16 bit int-type image, then you should transform img into img = img.astype('float')/65535*4095. xy_unit : number. The unit size of voxel on x- and y-axis by \u03bcm. Please check using ImageJ. z_unit : number. The unit size of voxel on z-axis by \u03bcm, which is also your step size of stack imaging. Please check using ImageJ. k1 : number. ILEE K1. for 3D mode we recommend K1 = 10^((log10(2.5)+log10(K2))/2). k2 : number. ILEE K2. single_k1 : bool, optional. Whether to use single-K mode (use only K1) to save time. The default is False. use_matlab : bool, optional. Whether to use MATLAB for ILEE. The default is False. use_matlabGPU : bool, optional. Whether to activate GPU_acceleration in MATLAB. The default is False. If use_matlab is False, this makes no difference. gauss_dif : Bool, optional. Whether the difference image is gaussian-blurred slightly for smoother render. Default is True. Returns float 3D array, the rendered 3D difference image, the same shape as input. analyze_actin_3d_standard (img, img_dif_ori, xy_unit, z_unit, oversampling_for_bundle = True, pixel_size = 1): Compute all cytoskeleton indices using 3d raw and difference image as input. Parameters img : 3D array. Input 3D image img_dif_ori : 3D array. The difference image to define the cytoskeleton components. xy_unit : number. The unit size of voxel on x- and y-axis by \u03bcm. Please check using ImageJ. z_unit : number. The unit size of voxel on z-axis by \u03bcm, which is also your step size of stack imaging. Please check using ImageJ. oversampling_for_bundle : bool, optional. Whether to use oversampled image to calculated diameter indices. Recommend to turn on for accuracy. The default is True. pixel_size : number, optional. The physical lenghth unit (on x- and y-axis) of your voxel, by micrometer (\u03bcm). The default is 1. If it is set as using physical length unit such as \u03bcm, it should be equal to the parameter xy_unit, and the unit \"PU\" in the output table should be considered as \u03bcm as well. Returns Pandas DataFrame, all cytoskeleton indices of input sample: occupancy, linear_density, skewness, cv, Diameter_tdt, Diameter_sdt, sev_act, branching_act, anisotropy.","title":"Processing individual sample"},{"location":"Help%20needed/","text":"Your Help in Need! Since ILEE_CSK aims to boost the accuracy and efficiency of image analysis of cytoskeleton, which should echo the community's demand, we are excited to learn critical information of related image process algorithms, bugs, and the demand. Please send us an email regarding any issues at lipai@msu.edu, or submit an issue in our GitHub home page (https://github.com/phylars/ILEE_CSK). This page will be continuously renewed parallel to our library update. A General Sparse Linear Solver on GPU ILEE uses a sparse linear solver, which means GPU acceleration can boost it 10-20 times faster. We have implanted the GPU acceleration mode using MATLAB with CUDA, but it requires users to have a MATLAB license and a CUDA-compatible GPU, which is not general enough. While we searched on the Internet, we could not find any GPU-based sparse linear solver that is general and open-sourced. We hope you can offer any recommendations on how to better substitute for our current solutions. Conditional gradient (CG) algorithm is preferred for the linear solve because it has the best performance in our tests. Upgrading Skeletonization Algorithm Many cytoskeleton indices depend on the skeleton image of the binary image (Note: skeleton image is an image rendered by thinning the binary image to one-pixel but remains topological structure.). We are using the Skeletonize function in the scikit-image, which is very slow in 3D mode. It is perhaps because this function uses a single process on CPU (mine is 10-20% CPU usage), and therefore the computational power is not used efficiently. If there are any recommendations on a new function/library for pixel/voxel image skeletonization that uses a faster algorithm or multi-processing mode, please reach out at lipai@msu.edu or our GitHub page. Bug report When following our tutorial/API and find bugs in the code, please report the issue. Please send an image sample and tell us your processing in detail so that we can repeat it. Tell us your demand If our algorithm does not fulfill your demands, please let us know what you wish to learn from your cytoskeleton image of your research or what functions you expect to have for our library. We aim to incorporate all possible functions for the community's best interest and therefore need your input to make this possible, so please contact us for anything that can help better our website. Thank you!","title":"Help Needed"},{"location":"Help%20needed/#your-help-in-need","text":"Since ILEE_CSK aims to boost the accuracy and efficiency of image analysis of cytoskeleton, which should echo the community's demand, we are excited to learn critical information of related image process algorithms, bugs, and the demand. Please send us an email regarding any issues at lipai@msu.edu, or submit an issue in our GitHub home page (https://github.com/phylars/ILEE_CSK). This page will be continuously renewed parallel to our library update.","title":"Your Help in Need!"},{"location":"Help%20needed/#a-general-sparse-linear-solver-on-gpu","text":"ILEE uses a sparse linear solver, which means GPU acceleration can boost it 10-20 times faster. We have implanted the GPU acceleration mode using MATLAB with CUDA, but it requires users to have a MATLAB license and a CUDA-compatible GPU, which is not general enough. While we searched on the Internet, we could not find any GPU-based sparse linear solver that is general and open-sourced. We hope you can offer any recommendations on how to better substitute for our current solutions. Conditional gradient (CG) algorithm is preferred for the linear solve because it has the best performance in our tests.","title":"A General Sparse Linear Solver on GPU"},{"location":"Help%20needed/#upgrading-skeletonization-algorithm","text":"Many cytoskeleton indices depend on the skeleton image of the binary image (Note: skeleton image is an image rendered by thinning the binary image to one-pixel but remains topological structure.). We are using the Skeletonize function in the scikit-image, which is very slow in 3D mode. It is perhaps because this function uses a single process on CPU (mine is 10-20% CPU usage), and therefore the computational power is not used efficiently. If there are any recommendations on a new function/library for pixel/voxel image skeletonization that uses a faster algorithm or multi-processing mode, please reach out at lipai@msu.edu or our GitHub page.","title":"Upgrading Skeletonization Algorithm"},{"location":"Help%20needed/#bug-report","text":"When following our tutorial/API and find bugs in the code, please report the issue. Please send an image sample and tell us your processing in detail so that we can repeat it.","title":"Bug report"},{"location":"Help%20needed/#tell-us-your-demand","text":"If our algorithm does not fulfill your demands, please let us know what you wish to learn from your cytoskeleton image of your research or what functions you expect to have for our library. We aim to incorporate all possible functions for the community's best interest and therefore need your input to make this possible, so please contact us for anything that can help better our website. Thank you!","title":"Tell us your demand"},{"location":"Tutorial/","text":"For users without Python experience ILEE_CSK is a Python library, which means you need to set up a Python environment to process your data. For beginners without any Python experience, we recommend the one-step way: Anaconda . Please find the Anaconda installer that applies to your system at https://www.anaconda.com/products/individual, and install. The default environment provided by Anaconda also includes most of the libraries you need to process your data. Anaconda is a well-established Python IDE (Integrated Development Environment); Spyder is for scientific calculation and visualization; therefore, you should regard it as a powerful calculator. When you have completed installing the library, open Spyder to compute your samples. You can use either the search engine on Spyder in your apps or open the Anaconda Navigator. An example is provided below: Next, you need to install ILEE_CSK and are going to use command lines. Please note that you should NOT use Windows command lines, but instead, open the Anaconda Prompt and enter your install commands ; this makes the intended libraries installed in the Anaconda environment rather than the windows default Python environment. You can either search Anaconda Prompt in your apps or use the Anaconda Navigator to open it. Here is a visual example of how it should look: The photo above shows the interface where you can install any library. We use this library for installing purposes; do not use Spyder for installing purposes. After you open the Anaconda Prompt, please check the next step to install the ILEE_CSK library. Installing ILEE_CSK ILEE_CSK is available on PyPI: pip install ILEE_CSK ILEE_CSK supports MATLAB-based GPU acceleration for native-3D image processing. If you have a MATLAB license and a CUDA GPU and wish to proceed with the 3D mode, please refer to Batch processing by 3D mode on the GPU section on the Tutorial page. (optional) Installing napari for 3D visualization The napari is a multi-dimensional image viewer for Python. It is an outstanding tool for confocal image visualization, especially for visualizing 3D images. We recommend you directly follow the instructions to install napari on their website at https://napari.org/. Cytoskeleton indices computation Batch processing all samples in a document Confocal images of cytoskeletons are usually taken as 3D stacks (Native 3D structure). The program supports batch processing of files starting from raw stack images in format of .TIFF regardless of whether you prefer 2D or 3D mode, which is our recommended way to process your data. If the source images are already 2D, please check the API to process the images individually. Generating TIFF raw images by FIJI (ImageJ). FIJI is a Java-based free-to-use image processing GUI software that is optimized for scientific use. If you do not already have it installed, please install it onto your device. Be sure to put all your confocal image files in the same folder. Then open FIJI and select Process => Batch => Convert. The Input folder is the one that contains your raw confocal-format files; the Output is the folder you would like to put in your generated TIFF files. Please note that output format MUST BE tiff, interpolation MUST be none, and scale factor MUST BE 1. This makes sure your tiff is raw data. Find your channel index and K2 To learn the data structure of the raw TIFF files you previously generated to finish parameter setting, please go to the path of one of the generated TIFF files and read it by skimage.io, such as: image_example_path = 'D:/my_experiments/generated_TIFF_images/sample_001.tiff' from skimage import io img = io.imread(image_example_path) Generally, the img should be a 4D array, and the dimension with the smallest size amongst the four dimensions should be the fluorescence channel. (For Python novice, you can check the Spyder variable explorer on the column \"size\"). For example, when using an Olympus confocal system, a user can get an array out of our image with the dimension size of (25, 3, 800, 800), which means (z, channel, x, y). Different confocal systems have numbers that occur in different orders. NOTE: Our batch processing pipeline function requires the channel to be the dimension with the smallest size and the dimension with the second lowest size to be z-axis resolution, which applies to most of the cytoskeleton confocal images. It is because the number of channels is generally no more significant than five, with a maximum of four fluorescence channels plus a transmission channel; the z-stack number is usually greater than five to cover the total cell. If there is an abnormal data structure, the batch processing function may not apply for the current version. We recommend you report your special case to us to help us improve the compatibility for the library. In order to figure out which of the channels is the cytoskeleton fluorescence channel, analyze. Generally, the channel order will be the same as the confocal setting and be aware that the Python index starts from 0 instead of 1. For example, when using channel 1 to see GFP-labeled actin, channel 2 to see chloroplast far-red light, and an added transmission channel to see the bright field, the objective index should be 0 (channel 1). However, to verify which one is the objective channel, try visualizing their projected image: To run batch processing, you need to figure out which of your channel is the cytoskeleton fluorescence channel you want to analyze. Generally, the channel order will be the same as the confocal setting and be aware that the Python array index starts from 0 instead of 1. For example, if your fist channel is GFP-labeled actin, and the second channel is chloroplast far-red light, with an third transmission channel to see the bright field, then the objective index should be 0 (for the first channel). However, we highly recommend you verify the channel index. To do this, you can try visualizing the projected image: import matplotlib.pyplot as plt img = img[:,0,:,:] # This is assuming my data structure is (25, 3, 800, 800) and I guess 0 is my actin channel index. You should locate your channel dimension and use the channel indexes you want to check. img = np.amax(img, axis=0) #In my case, my first dimension (index 0) is z-axis, if your z-axis is another dimension, please change accordingly. #run this three line together: plt.figure(figsize = (18, 18)) plt.imshow(img) plt.show() Another way is to directly see the 3D voxel image by napari: import napari with napari.gui_qt(): viewer = napari.Viewer() for i in range(3): #This 3 is the total number of your channels. Change accordingly. viewer.add_image(img[:,i,:,:]) After figuring out your data structure and the index of your objective channel, you can start to evaluate your K2 for the sample batch using the function opt_k2 . For example, if my index of cytoskeleton fluorescence channel is 0, you can do like such: import ILEE_CSK folder = 'D:/my_experiments/generated_TIFF_images/' the_optimal_K2 = ILEE_CSK.opt_k2(folder_path = folder, target_channel = 0) It is also possible to only have one channel when taking confocal images, in which case, the input data structure may be a 3D array rather than 4D. In that case, it needs to set target_channel to None. the_optimal_K2 = ILEE_CSK.opt_k2(folder_path = folder, target_channel = None) Batch processing by 2D mode After determining the optimal K2 for the sample pool, you can finish batch processing by one step using the same fluorescence channel index: results = ILEE_CSK.analyze_document_2D (folder_path = folder, obj_channel = 0, k2 = the_optimal_K2) Please read the API to learn about the parameters. The obj_channel should be your targeted channel index, or None if imported Tiffs are 3D array. The \"results\" will be a table in format of Pandas DataFrame, which you can check and process within python IDE. You may also want to directly output it as an Excel file, which can be done as such: result.to_excel('D:/my_experiments/generated_TIFF_images/analysis_result.xlsx') Batch processing by 3D mode on CPU Batch processing on 3D mode use a similar pipeline function that is easy to use. We recommend no less than 16G memory, otherwise it may fail. You need to manually check your voxel size on x/y- and z-axis by \u03bcm, if you don't remember. A straightforward way is to check by FIJI (ImageJ); after open one of you samples, select Image => Show Info to achieve it. In the example above, my voxel size is 0.132\u03bcm on the x/y-axis and 0.5\u03bcm on the z-axis. Then, initiate the batch processing function in 3D mode using the channel index, K2, and voxel size you have obtained. Here is an example using the image information of mine: results = ILEE_CSK.analyze_document_3D (folder_path = folder, obj_channel = 0, #example value; should be your cytoskeleton channel k2 = the_optimal_K2, xy_unit = 0.132, #example value z_unit = 0.5, #example value pixel_size = 0.132, #example value single_k = True, use_GPU = False) The setting above uses CPU mode, which is very slow (5~7min per 25x800x800 image on i7-6700K). Therefore, we highly recommend turn on single_k mode to save half of the time with an acceptable sacrifice at accuracy on thick filaments. Batch processing by 3D mode on GPU If a valid GPU and MATLAB are accessible, we highly recommend using GPU mode to conduct 3D mode computation. Make sure the MATLAB includes the necessary Support Packages: https://www.mathworks.com/help/gpucoder/gs/install-prerequisites.html. The CUDA Toolkit can be installed at https://developer.nvidia.com/cuda-gpus, if you did not. We did not test if AMD GPU works on MATLAB. You are welcomed to tell us about your AMD GPU. Finally, please install the MATLAB Engine module for the python environment: https://www.mathworks.com/help/matlab/matlab_external/install-the-matlab-engine-for-python.html. When using the Anaconda, please make sure to use the Anaconda Prompt rather than the Apple or Windows cmd. When ILEE_CSK is imported with MATLAB Engine module (matlab.engine) installed, a conformation message will be printed: Otherwise, it will say: However, it is not a system error, and all the other functions will be fine. If the MATLAB Engine is recognized, then run batch processing on 3D mode with the GPU by setting use_GPU = True: results = ILEE_CSK.analyze_document_3D (folder_path = folder, obj_channel = 0, #example value; should be your cytoskeleton channel k2 = the_optimal_K2, xy_unit = 0.132, #example value z_unit = 0.5, #example value pixel_size = 0.132, #example value single_k = True, use_GPU = True) This mode additionally requires a temporary directory to save the image and matrix data. The default path is 'D:/MATLAB_temp' and sets automatically. If you do not have a Disk D:/ or wants to change it, change it by: ILEE_CSK.temp_directory = 'your_preferred_path' Processing single sample Please refer to our API where we discribe functions for ILEE thresholding and index compuation for single image sample. While it can be very flexible, here are examples of how single image files can be processed. This is a 2D mode example: import ILEE_CSK from skimage import io import numpy as np img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = np.amax(img, axis=0) #maximum projection img = img-img.min() #cut off useless values for LUT img = img.astype('float') #make it float data type img_dif = ILEE_CSK.ILEE_2d (img, k2 = 666, k1 = 2.5, pL_type = 'pL_8', gauss_dif = True) my_data = ILEE_CSK.analyze_actin_2d_standard (img = img, img_dif = img_dif, pixel_size = 1) 3D mode is similar but without projection: import ILEE_CSK from skimage import io import numpy as np img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = img-img.min() #cut off useless values for LUT img = img.astype('float') #make it float data type img_dif_ori = ILEE_CSK.ILEE_3d(img, xy_unit = 0.053, z_unit = 0.16, k1 = 2.5, k2 = 666, single_k1 = False, use_matlab = True, use_matlabGPU = True, gauss_dif = True) #I assume I have a CUDA graphic card. Set your own voxel size. my_data = ILEE_CSK.analyze_actin_3d_standard (img = img, img_dif_ori = img_dif_ori, xy_unit = 0.053, z_unit = 0.16) Image visualization Checking difference image or binary image \"Difference image\" means the pre-processed input image minus the threshold image -- literally to see the contrast level between the input cytoskeleton image and the threshold image. Binary image means the segmented cytoskeleton fraction, where 1 (True) means the pixel is judged as cytoskeleton and 0 (False) means not. Below is an example how to visualize it for 2D mode: import ILEE_CSK from skimage import io import numpy as np import matplotlib.pyplot as plt img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = np.amax(img, axis=0) img = img-img.min() img = img.astype('float') img_dif = ILEE_CSK.ILEE_2d (img, k2 = 666, k1 = 2.5, pL_type = 'pL_8', gauss_dif = True) #check your difference image: plt.figure(figsize = (16,16)) plt.imshow(img_dif) plt.axis('off') plt.show() #check your binary image: img_binary = img_dif > 0 plt.figure(figsize = (16,16)) plt.imshow(img_binary) plt.axis('off') plt.show() Below is an example for 3D mode, napari is used for 3D visualization: import ILEE_CSK from skimage import io import numpy as np img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = img-img.min() img = img.astype('float') img_dif_ori = ILEE_CSK.ILEE_3d(img, xy_unit = 0.053, z_unit = 0.16, k1 = 2.5, k2 = 666, single_k1 = False, use_matlab = True, use_matlabGPU = True, gauss_dif = True) from skimage.transform import resize import napari #remember the output of ILEE_CSK.ILEE_3d generally has cuboid rather than cubic voxel, so you must interpolate it into cubic voxels, such as below: img_interp = resize(img, (30,800,800)) #Assuming I have a 10*800*800 input in the very beginning, so is my img_dif. Given that 0.16/0.053 ~= 3, I will interpolate it into 30*800*800. This image will exactly look like your biological sample. img_dif = resize(img_dif, (30,800,800)) img_binary = img_dif > 0 #open a napari viewer and import your o 2D or 3D images. with napari.gui_qt(): viewer = napari.Viewer() viewer.add_image(img_binary) viewer.add_image(img_interp)","title":"Tutorial"},{"location":"Tutorial/#for-users-without-python-experience","text":"ILEE_CSK is a Python library, which means you need to set up a Python environment to process your data. For beginners without any Python experience, we recommend the one-step way: Anaconda . Please find the Anaconda installer that applies to your system at https://www.anaconda.com/products/individual, and install. The default environment provided by Anaconda also includes most of the libraries you need to process your data. Anaconda is a well-established Python IDE (Integrated Development Environment); Spyder is for scientific calculation and visualization; therefore, you should regard it as a powerful calculator. When you have completed installing the library, open Spyder to compute your samples. You can use either the search engine on Spyder in your apps or open the Anaconda Navigator. An example is provided below: Next, you need to install ILEE_CSK and are going to use command lines. Please note that you should NOT use Windows command lines, but instead, open the Anaconda Prompt and enter your install commands ; this makes the intended libraries installed in the Anaconda environment rather than the windows default Python environment. You can either search Anaconda Prompt in your apps or use the Anaconda Navigator to open it. Here is a visual example of how it should look: The photo above shows the interface where you can install any library. We use this library for installing purposes; do not use Spyder for installing purposes. After you open the Anaconda Prompt, please check the next step to install the ILEE_CSK library.","title":"For users without Python experience"},{"location":"Tutorial/#installing-ilee_csk","text":"ILEE_CSK is available on PyPI: pip install ILEE_CSK ILEE_CSK supports MATLAB-based GPU acceleration for native-3D image processing. If you have a MATLAB license and a CUDA GPU and wish to proceed with the 3D mode, please refer to Batch processing by 3D mode on the GPU section on the Tutorial page.","title":"Installing ILEE_CSK"},{"location":"Tutorial/#optional-installing-napari-for-3d-visualization","text":"The napari is a multi-dimensional image viewer for Python. It is an outstanding tool for confocal image visualization, especially for visualizing 3D images. We recommend you directly follow the instructions to install napari on their website at https://napari.org/.","title":"(optional) Installing napari for 3D visualization"},{"location":"Tutorial/#cytoskeleton-indices-computation","text":"","title":"Cytoskeleton indices computation"},{"location":"Tutorial/#batch-processing-all-samples-in-a-document","text":"Confocal images of cytoskeletons are usually taken as 3D stacks (Native 3D structure). The program supports batch processing of files starting from raw stack images in format of .TIFF regardless of whether you prefer 2D or 3D mode, which is our recommended way to process your data. If the source images are already 2D, please check the API to process the images individually.","title":"Batch processing all samples in a document"},{"location":"Tutorial/#generating-tiff-raw-images-by-fiji-imagej","text":"FIJI is a Java-based free-to-use image processing GUI software that is optimized for scientific use. If you do not already have it installed, please install it onto your device. Be sure to put all your confocal image files in the same folder. Then open FIJI and select Process => Batch => Convert. The Input folder is the one that contains your raw confocal-format files; the Output is the folder you would like to put in your generated TIFF files. Please note that output format MUST BE tiff, interpolation MUST be none, and scale factor MUST BE 1. This makes sure your tiff is raw data.","title":"Generating TIFF raw images by FIJI (ImageJ)."},{"location":"Tutorial/#find-your-channel-index-and-k2","text":"To learn the data structure of the raw TIFF files you previously generated to finish parameter setting, please go to the path of one of the generated TIFF files and read it by skimage.io, such as: image_example_path = 'D:/my_experiments/generated_TIFF_images/sample_001.tiff' from skimage import io img = io.imread(image_example_path) Generally, the img should be a 4D array, and the dimension with the smallest size amongst the four dimensions should be the fluorescence channel. (For Python novice, you can check the Spyder variable explorer on the column \"size\"). For example, when using an Olympus confocal system, a user can get an array out of our image with the dimension size of (25, 3, 800, 800), which means (z, channel, x, y). Different confocal systems have numbers that occur in different orders. NOTE: Our batch processing pipeline function requires the channel to be the dimension with the smallest size and the dimension with the second lowest size to be z-axis resolution, which applies to most of the cytoskeleton confocal images. It is because the number of channels is generally no more significant than five, with a maximum of four fluorescence channels plus a transmission channel; the z-stack number is usually greater than five to cover the total cell. If there is an abnormal data structure, the batch processing function may not apply for the current version. We recommend you report your special case to us to help us improve the compatibility for the library. In order to figure out which of the channels is the cytoskeleton fluorescence channel, analyze. Generally, the channel order will be the same as the confocal setting and be aware that the Python index starts from 0 instead of 1. For example, when using channel 1 to see GFP-labeled actin, channel 2 to see chloroplast far-red light, and an added transmission channel to see the bright field, the objective index should be 0 (channel 1). However, to verify which one is the objective channel, try visualizing their projected image: To run batch processing, you need to figure out which of your channel is the cytoskeleton fluorescence channel you want to analyze. Generally, the channel order will be the same as the confocal setting and be aware that the Python array index starts from 0 instead of 1. For example, if your fist channel is GFP-labeled actin, and the second channel is chloroplast far-red light, with an third transmission channel to see the bright field, then the objective index should be 0 (for the first channel). However, we highly recommend you verify the channel index. To do this, you can try visualizing the projected image: import matplotlib.pyplot as plt img = img[:,0,:,:] # This is assuming my data structure is (25, 3, 800, 800) and I guess 0 is my actin channel index. You should locate your channel dimension and use the channel indexes you want to check. img = np.amax(img, axis=0) #In my case, my first dimension (index 0) is z-axis, if your z-axis is another dimension, please change accordingly. #run this three line together: plt.figure(figsize = (18, 18)) plt.imshow(img) plt.show() Another way is to directly see the 3D voxel image by napari: import napari with napari.gui_qt(): viewer = napari.Viewer() for i in range(3): #This 3 is the total number of your channels. Change accordingly. viewer.add_image(img[:,i,:,:]) After figuring out your data structure and the index of your objective channel, you can start to evaluate your K2 for the sample batch using the function opt_k2 . For example, if my index of cytoskeleton fluorescence channel is 0, you can do like such: import ILEE_CSK folder = 'D:/my_experiments/generated_TIFF_images/' the_optimal_K2 = ILEE_CSK.opt_k2(folder_path = folder, target_channel = 0) It is also possible to only have one channel when taking confocal images, in which case, the input data structure may be a 3D array rather than 4D. In that case, it needs to set target_channel to None. the_optimal_K2 = ILEE_CSK.opt_k2(folder_path = folder, target_channel = None)","title":"Find your channel index and K2"},{"location":"Tutorial/#batch-processing-by-2d-mode","text":"After determining the optimal K2 for the sample pool, you can finish batch processing by one step using the same fluorescence channel index: results = ILEE_CSK.analyze_document_2D (folder_path = folder, obj_channel = 0, k2 = the_optimal_K2) Please read the API to learn about the parameters. The obj_channel should be your targeted channel index, or None if imported Tiffs are 3D array. The \"results\" will be a table in format of Pandas DataFrame, which you can check and process within python IDE. You may also want to directly output it as an Excel file, which can be done as such: result.to_excel('D:/my_experiments/generated_TIFF_images/analysis_result.xlsx')","title":"Batch processing by 2D mode"},{"location":"Tutorial/#batch-processing-by-3d-mode-on-cpu","text":"Batch processing on 3D mode use a similar pipeline function that is easy to use. We recommend no less than 16G memory, otherwise it may fail. You need to manually check your voxel size on x/y- and z-axis by \u03bcm, if you don't remember. A straightforward way is to check by FIJI (ImageJ); after open one of you samples, select Image => Show Info to achieve it. In the example above, my voxel size is 0.132\u03bcm on the x/y-axis and 0.5\u03bcm on the z-axis. Then, initiate the batch processing function in 3D mode using the channel index, K2, and voxel size you have obtained. Here is an example using the image information of mine: results = ILEE_CSK.analyze_document_3D (folder_path = folder, obj_channel = 0, #example value; should be your cytoskeleton channel k2 = the_optimal_K2, xy_unit = 0.132, #example value z_unit = 0.5, #example value pixel_size = 0.132, #example value single_k = True, use_GPU = False) The setting above uses CPU mode, which is very slow (5~7min per 25x800x800 image on i7-6700K). Therefore, we highly recommend turn on single_k mode to save half of the time with an acceptable sacrifice at accuracy on thick filaments.","title":"Batch processing by 3D mode on CPU"},{"location":"Tutorial/#batch-processing-by-3d-mode-on-gpu","text":"If a valid GPU and MATLAB are accessible, we highly recommend using GPU mode to conduct 3D mode computation. Make sure the MATLAB includes the necessary Support Packages: https://www.mathworks.com/help/gpucoder/gs/install-prerequisites.html. The CUDA Toolkit can be installed at https://developer.nvidia.com/cuda-gpus, if you did not. We did not test if AMD GPU works on MATLAB. You are welcomed to tell us about your AMD GPU. Finally, please install the MATLAB Engine module for the python environment: https://www.mathworks.com/help/matlab/matlab_external/install-the-matlab-engine-for-python.html. When using the Anaconda, please make sure to use the Anaconda Prompt rather than the Apple or Windows cmd. When ILEE_CSK is imported with MATLAB Engine module (matlab.engine) installed, a conformation message will be printed: Otherwise, it will say: However, it is not a system error, and all the other functions will be fine. If the MATLAB Engine is recognized, then run batch processing on 3D mode with the GPU by setting use_GPU = True: results = ILEE_CSK.analyze_document_3D (folder_path = folder, obj_channel = 0, #example value; should be your cytoskeleton channel k2 = the_optimal_K2, xy_unit = 0.132, #example value z_unit = 0.5, #example value pixel_size = 0.132, #example value single_k = True, use_GPU = True) This mode additionally requires a temporary directory to save the image and matrix data. The default path is 'D:/MATLAB_temp' and sets automatically. If you do not have a Disk D:/ or wants to change it, change it by: ILEE_CSK.temp_directory = 'your_preferred_path'","title":"Batch processing by 3D mode on GPU"},{"location":"Tutorial/#processing-single-sample","text":"Please refer to our API where we discribe functions for ILEE thresholding and index compuation for single image sample. While it can be very flexible, here are examples of how single image files can be processed. This is a 2D mode example: import ILEE_CSK from skimage import io import numpy as np img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = np.amax(img, axis=0) #maximum projection img = img-img.min() #cut off useless values for LUT img = img.astype('float') #make it float data type img_dif = ILEE_CSK.ILEE_2d (img, k2 = 666, k1 = 2.5, pL_type = 'pL_8', gauss_dif = True) my_data = ILEE_CSK.analyze_actin_2d_standard (img = img, img_dif = img_dif, pixel_size = 1) 3D mode is similar but without projection: import ILEE_CSK from skimage import io import numpy as np img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = img-img.min() #cut off useless values for LUT img = img.astype('float') #make it float data type img_dif_ori = ILEE_CSK.ILEE_3d(img, xy_unit = 0.053, z_unit = 0.16, k1 = 2.5, k2 = 666, single_k1 = False, use_matlab = True, use_matlabGPU = True, gauss_dif = True) #I assume I have a CUDA graphic card. Set your own voxel size. my_data = ILEE_CSK.analyze_actin_3d_standard (img = img, img_dif_ori = img_dif_ori, xy_unit = 0.053, z_unit = 0.16)","title":"Processing single sample"},{"location":"Tutorial/#image-visualization","text":"","title":"Image visualization"},{"location":"Tutorial/#checking-difference-image-or-binary-image","text":"\"Difference image\" means the pre-processed input image minus the threshold image -- literally to see the contrast level between the input cytoskeleton image and the threshold image. Binary image means the segmented cytoskeleton fraction, where 1 (True) means the pixel is judged as cytoskeleton and 0 (False) means not. Below is an example how to visualize it for 2D mode: import ILEE_CSK from skimage import io import numpy as np import matplotlib.pyplot as plt img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = np.amax(img, axis=0) img = img-img.min() img = img.astype('float') img_dif = ILEE_CSK.ILEE_2d (img, k2 = 666, k1 = 2.5, pL_type = 'pL_8', gauss_dif = True) #check your difference image: plt.figure(figsize = (16,16)) plt.imshow(img_dif) plt.axis('off') plt.show() #check your binary image: img_binary = img_dif > 0 plt.figure(figsize = (16,16)) plt.imshow(img_binary) plt.axis('off') plt.show() Below is an example for 3D mode, napari is used for 3D visualization: import ILEE_CSK from skimage import io import numpy as np img = io.imread('your_path') #substitute to your tiff file path img = ILEE_CSK.rearrange_image_dimension(img, target_channel = 0) #Assuming that my array is 4D (including channel demension and my objective channel is 0) img = img-img.min() img = img.astype('float') img_dif_ori = ILEE_CSK.ILEE_3d(img, xy_unit = 0.053, z_unit = 0.16, k1 = 2.5, k2 = 666, single_k1 = False, use_matlab = True, use_matlabGPU = True, gauss_dif = True) from skimage.transform import resize import napari #remember the output of ILEE_CSK.ILEE_3d generally has cuboid rather than cubic voxel, so you must interpolate it into cubic voxels, such as below: img_interp = resize(img, (30,800,800)) #Assuming I have a 10*800*800 input in the very beginning, so is my img_dif. Given that 0.16/0.053 ~= 3, I will interpolate it into 30*800*800. This image will exactly look like your biological sample. img_dif = resize(img_dif, (30,800,800)) img_binary = img_dif > 0 #open a napari viewer and import your o 2D or 3D images. with napari.gui_qt(): viewer = napari.Viewer() viewer.add_image(img_binary) viewer.add_image(img_interp)","title":"Checking difference image or binary image"}]}